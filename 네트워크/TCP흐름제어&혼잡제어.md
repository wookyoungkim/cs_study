\1. 흐름 제어 (Flow Control)

 

송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법이다.

 

\- Stop-and-Wait

 

매번 전송한 패킷에 대해 확인 응답을 받을때까지 기다린 후 다음 패킷을 전송하는 방법

 

\- GBN (Go-Back-N)

 

수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송해 데이터 흐름을 조절하는 제어기법

 

 



![img](https://blog.kakaocdn.net/dn/bkUlmc/btqT90Y7rR0/JqO2cyauI6ArIX6KtXrelK/img.jpg)



GBN에서는 확인 응답이 안된 가장 오래된 가장 오래된 패킷의 순서번호를 base로 지정하고 윈도우의 크기를 N으로 지정한다. 따라서 확인 응답이 안된 패킷은 윈도우의 크기인 N보다 크면 안된다. 위 사진에서 노란 부분은 이미 전송 된 부분이고 파란 부분은 아직 전송이 안된 부분이다. 이번에 올 패킷이 3번 패킷이라면 (nextseqnum == 3) 수신측에서 4, 5, 6... 등의 패킷을 보내면 모두 버리며 3번 패킷이 오기만을 기다리는 방식이다.

 

따라서 패킷 하나의 문제로 많은 패킷을 재전송하게되는 비효율적인 상황이 발생한다. 이를 해결하기 위해 나온 방법이 SR (Selective Repeat) 이다.

 

\- SR (Selective Repeat)

 

SR은 이름에서 알 수 있듯이, 수신자에서 오류가 발생한것으로 예상되는 패킷만을 송신자가 다시 전송한다. 따라서 불필요한 재전송이 많이 사라진다. 이때 각각의 재전송은 개별적인 확인 응답을 요구한다. 전송에서 슬라이딩 윈도우로 base 부분부터 완료된만큼 이동시킨다. 설명하기보다 직접 애니메이션으로 확인하는 것이 더 이해가 잘 될 것이라고 생각해 아래 링크를 첨부한다. SR과 GBN의 동작을 보여주는 사이트이다.

 

[www2.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/](https://www2.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/)

[ Selective Repeat / Go Back N www2.tkn.tu-berlin.de](https://www2.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/)

\- fast retransmit (빠른 재전송)

 

타임아웃에 의한 재전송에서 타임아웃 주기가 길면 지연 시간이 증가할 수 있다. 이러한 문제를 해결하기 위해 송신자는 종종 중복 ACK를 이용해 패킷 손실을 미리 발견할 수 있다. 송신자가 먼저 도착해야할 패킷이 도착하지 않고 더 큰 번호의 패킷이 도착한 경우에도 ACK 패킷을 보낸다. 이후 정상적으로 진행되었을 경우 더 큰 번호의 패킷에 해당하는 ACK 패킷을 받게 되므로 중복된 ACK 패킷을 받게 되고 문제가 되는 순번의 패킷을 재전송 해줄 수있다. 중복된 순번의 패킷을 3개 받으면 재전송을 하게 되며 이는 TCP 세그먼트의 타이머가 만료되기 전에 손실 세그먼트를 재전송하는ㄱ ㅕㅇ우이므로 빠른 재전송이라고 한다. 이때 혼잡이 일어나 윈도우의 크기가 약간 줄어든다.

 

\- TCP와 GBN, SR

 

TCP는 base를 기억하고 전송될 다음 바이트를 유지해야한다. 이는 GBN와 유사한 모습이다. 하지만 1, 2, .., N인 세그먼트들을 전송하고 수신측에 오류 없이 순서대로 전달 되는 경우를 가정하자. 이때 패킷 i < N인 i에 대해서 확인 응답이 손실되면 GBN의 경우 i + 1, i + 2, ... N 을 모두 재전송하는 반면 TCP는 i번 배킷만을 재전송 할 것이다. 따라서 이 부분은 SR과 유사하다고 볼 수 있으며 TCP는 GBN과 SR의 혼합으로 분류하는 것이 적절하다

 

 

\2. TCP 에서의 흐름 제어

 



![img](https://blog.kakaocdn.net/dn/oOVxV/btqT7WQtZbL/ua51r2Hl8FhTVkk9kTXEkK/img.jpg)



TCP는 송신자가 수신 윈도우(receive window)라는 변수를 유지하여 흐름제어를 제공한다. 수신 윈도우는 수신 측에서 사용 가능한 버퍼 공간이 얼마나 되는지 송신자에게 알려주는데 사용한다.

TCP는 할당된 버퍼의 오버플로우를 허용하지 않으므로 LastByteRcvd - LastByteRead <= RvcBuffer 가 성립한다.

(LastByteRcvd : 수신측에서 버퍼로 부터 읽힌 데이터 스트림의 마지막 바이트 수

 LastByteRead : 수신측에서 네트워크로 부터 도착하여 수신 버퍼에 저장된 데이터 스트림의 마지막 바이트 수)

따라서 rwnd = RvcBuffer - LastByteRcvd - LastByteRead가 성립한다.

이를 이용해서 흐름을 제어한다. 여기에 한가지 문제점이 있는데 수신자가 송신자에게 보낼게 없을 때 rwnd == 0에서 이후에 rwnd > 0 이 되었을 때 알려줄 방법이 없다. 이는 수신자가 rwnd이 0일 때 수신자가 지속적으로 1바이트 데이터로 세그먼트를 계속 전송하도록 요구하여 해결할 수 있다.

 

\3. 혼잡 제어(Congestion Control)

 

송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법이다. 송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달되는데 라우터는 항상 한가로운 상황이 아니다. 한 라우터에 요청이 몰리게 될 경우 해당 라우터는 요청들을 모두 해결할 수 없다. 따라서 재전송을 요청하게 되고 혼잡을 가중시켜 오버플로우나 데이터 손실을 발생시킨다.

 

\4. TCP 혼잡제어

 

TCP에서 혼잡제어를 하는 방법은 종단간의 혼잡제어와 네트워크 지원 혼잡제어가 있다. 이 중 종단간의 혼잡제어를 사용해야하는데 이 이유는 IP 계층이 네트워크 혼잡에 관해서 종단 시스템에게 어떠한 직접적인 피드백도 제공하지 않기 때문이다.

 

\- 혼잡 윈도우 (congetion window)

 

송신측에서는 TCP 혼잡제어를 위해 추가적인 변수인 혼잡 윈도우(cwnd라 표기)를 사용한다. 송신하는 쪽에서 확인응답이 안 된 데이터 양은 cwnd와 rwnd의 최솟값을 초과하지 않는다. LastByteSent - LastByteAcked <= min(cwnd, rwnd) 으로 나타낼 수 있고 이때 cwnd의 값을 조정하여 송신자는 데이터를 전송하는 비율을 조절할 수 있다. 송신자는 손실 이벤트(타임 아웃 또는 3개의 중복된 ACK 수신)가 발생하였을 때 혼잡이 발생하였음을 알 수 있다. 손실 이벤트가 발생하지 않았을 경우, 송신자에게 아직 확인 응답을 받지 못한 세그먼트들에 대한 확인 응답들이 도착할 것이다. 이 응답의 빈도수에 따라 혼잡도를 파악할 수 있다. 따라서 확인 응답이 많이 올 경우 cwnd의 크기를 빠르게 증가시키고 적게 올 경우 cwnd의 크기를 천천히 증가시킨다.

 

\- 슬로우 스타트 (solow start)

 

TCP 연결이 시작될 때 cwnd의 값은 일반적으로 1 MMS로 초기화되고 그에 따라 초기 전송률은 MMS / RTT이 된다. 슬로우 스타트 상태에서는 TCP가 혹인 응답을 받을 때마다 cwnd의 크기를 1 MMS 증가시킨다. 따라서 한 주기가 지날 때 마다 혼잡 윈도우의 크기는 2배가 된다. 손실 이벤트가 발생했을 경우 ( 혼잡이 일어났을 경우 ) cwnd 값을 1로 바꾸고 다시 슬로 스타트를 시작한다. 이때 두 번째 상태 변수인 ssthresh (slow start threshold)를 마지막 cwnd의 값의 절반으로 바꿔준다. 따라서 이후에 cwnd이 ssthresh값에 도달하였을 때 cwnd 값을 2배를 하면 또 혼잡이 일어날 확률이 높을 것이다. 그러므로 cwnd 값을 천천히 증가시킨다.



![img](https://blog.kakaocdn.net/dn/bCHqYT/btqTV9KUdl5/eYWMbR7HFDXeJVVIt5ADqk/img.jpg)



\- 빠른 회복 (Fast Recovery)

 

빠른 회복에서는 cwnd 값이 TCP를 빠른 회복 상태로 들어가게 했던 세그먼트에 대한 중복된 ACK를 수신할 때마다 1 MMS만큼씩 증가된다. 빠른 회복은 TCP의 권장 사항이지만 필수 사항은 아니다. 초기에 Tahoe라 불리는 TCP 버전에서는 slow start 정책을 채택하고 타임아웃으로 표시되거나 3개의 중복 ACK가 표시되는 손실이 발생하면 무조건 윈도우를 1 MMS로 줄이고, 슬로 스타트 단계로 들어갔다. 새로운 버전인 TCP Reno에서는 slow start 방식을 채택하되 혼잡이 일어났을 경우 최종적인 cwnd의 값을 cwnd / 2로 설정하고 이후 선형적으로 증가시킨다.



![img](https://blog.kakaocdn.net/dn/dJI19d/btqT8HyRPVN/sjCvoKb8QHEaIo1DGJezKk/img.jpg)